---
title: "TMDB Prediction - R-Collab"
author: "Mike and Goutham"
date: "September 22, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TMDB Predict - R Collab

## 1. Data loading and cleaning

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(jsonlite)
library(DT)

```

```{r data loading}
data <- read_csv("train.csv")
print(data)
```

We load our initial data as a tibble, and start inspecting it. As a tibble, we can safely load it and it just gives us the first ten rows with color-coded information on column types.

In looking at the data, some of the columns are poorly-formed JSON data. They have (for example), single quotation marks where JSON requires double. Changing all the singles to doubles would mess up all of the single quotation marks already present in the data (possessives, french connectives, etc.) and so brute force gsub() and manually editing the data in a spreadsheet were going to end up being too time intensive.

Luckly, Georgi Petkov posted some code on the Kaggle website (https://www.kaggle.com/georgipetkov/json-columns-to-data-frame) that parses this particular data set rather well. It strips all of the punctuations, loads the data into matrices, and then converts them to tibbles.


```{r Petkov cast, warning=FALSE}

cast_list <- list()

for (i in seq_along(data$cast)) {
  cast_list[[i]] <- data$cast[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>%  #extract everything between {}
    str_split("(?<=[:digit:]|[:punct:]), ", n=Inf,simplify = TRUE) %>%       #split on ","
    str_extract_all('(?<=\\:[:space:]).*') %>% #get the part after the semicolon
    str_replace_all("'|\"","") %>% #clean the unwanted punctuation
    matrix( ncol = 8,  byrow = TRUE,dimnames=list(c(),
                                                  c("cast_id","character","credit_id","gender","id", "name","order","profile_path"))) %>% #convert to matrix
    as_tibble(stringsAsFactors = FALSE)#convert the matrix to tibble
}

# Name the list
names(cast_list) <- c(1:3000) #name the list with the sequential number of the list element

# Create df with a column that identifies each movie
cast_df <- bind_rows(cast_list, .id = 'movie_id')#create single df with a column that identifies the movies


cast_df  %>% 
  head(10) %>%
  DT::datatable()

```

```{r Petkov genres, warning=FALSE}
genres_list <- list()
for (i in seq_along(data$genres)) {
  genres_list[[i]] <- data$genres[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("id","name"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(genres_list) <- c(1:3000)

genres_df <- bind_rows(genres_list, .id = 'movie_id')

genres_df %>% 
  head(10) %>% 
  DT::datatable()

```

```{r Petkov production companies, warning=FALSE}
production_companies_list <- list()
for (i in seq_along(data$production_companies)) {
  production_companies_list[[i]] <- data$production_companies[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("name","id"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(production_companies_list) <- c(1:3000)

production_companies_df <- bind_rows(production_companies_list, .id = 'movie_id')


production_companies_df %>% 
  head(10) %>% 
  DT::datatable()

```

```{r Petkov crew, warning=FALSE}

crew_list <- list()

for (i in seq_along(data$crew)) {
  crew_list[[i]] <- data$crew[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 7,  byrow = TRUE,dimnames=list(c(),
   c("credit_id","department","gender","id","job","name","profile_path"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(crew_list) <- c(1:3000)

crew_df <- bind_rows(crew_list, .id = 'movie_id')

crew_df%>% 
  head(10) %>% 
  DT::datatable()
```


## 2. Exploratory Data Analysis

Let's see what we have in the 'budget' column.

```{r budget EDA}
plot <- ggplot(data = data) + 
  geom_histogram(aes(x = budget), fill = "dark green", alpha = 0.5)
print(plot)

```

So, most of the movies in the data are very inexpensively made, and by the time we get to $100,000 (1 * 10^8) in the graph, we're dealing with very few.  We also have a ton of movies with a budget of zero, which we can safely assume means the budget is unknown.

Let's zoom on the left side of this graph.

```{r budget2 EDA}
cheap.movies <- subset(data, budget > 0 & budget < 10000000)

plot <- ggplot(data = cheap.movies) + 
  geom_histogram(aes(x = budget), fill = "dark green", alpha = 0.5)
print(plot)

```

Looks like the movies between 0 and 10 million are fairly even distributed, getting more sparse as they approach 10 million.

We can guess that there's some sort of relationship between budget and revenue, but lets visualize and see.

```{r budget and revenue}
nonzero.movies <- subset(data, budget > 0)

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue), color = "dark green", alpha = 0.5)
print(plot)
```

Our guess would appear to be roughly accurate.

Let's add a linear regression line.

```{r budget and revenue with linear regression}
nonzero.movies <- subset(data, budget > 0)

linear.model <- lm(budget ~ revenue, data = nonzero.movies)
predicted.revenue <- data.frame(predicted = predict(linear.model, nonzero.movies))

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue), color = "dark green", alpha = 0.5) +
  geom_line(color = "blue", data = predicted.revenue, aes(x = predicted, y = nonzero.movies$revenue))
print(plot)
```

What about language and budget?

```{r language and budget}
plot <- ggplot(data = data, aes(x = original_language, y = budget)) +
  geom_boxplot(color = "light blue")

print(plot)

```

The only languages that make a dent in budget are English (overwhelmingly the highest budgets), then French, Chinese (both zh and cn (mainland Chinese simplified characters)) and Portuguese. Interestingly, it appears there are no mega-budget Hindi language films.

Let's go back and redo our earlier budget and revenue graph, this time coloring the dots by film language.

```{r budget revenue and language}
nonzero.movies <- subset(data, budget > 0)
nonzero.movies <- mutate(nonzero.movies, is.english = if_else(original_language == "en", "True", "False"))
print(head(nonzero.movies$is.english))

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue, color = is.english), alpha = 0.5)
print(plot)
```

What are those non-English outliers?

```{r non english outliers}
non.english <- subset(nonzero.movies, original_language != "en")
non.english.sorted <- top_n(non.english, 5, revenue)
print(non.english.sorted$original_title)

```

Of those, I've (Mike speaking here) only see "La Vita" and found it amazing. Might be a good viewing list for the future.

## 3. Feature Engineering

### A. Making a profit column

## 4. Prediction 1

## 5. Validation 1

## 6. Prediction 2

## 7. Validation 2

<!-- and so on... -->

