---
title: "TMDB Prediction - R-Collab"
author: "Mike and Goutham"
date: "September 22, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TMDB Predict - R Collab

## 1. Data loading and cleaning

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(jsonlite)
library(DT)

```

```{r data loading}
data <- read_csv("train.csv")
print(data)
```

We load our initial data as a tibble, and start inspecting it. As a tibble, we can safely load it and it just gives us the first ten rows with color-coded information on column types.

In looking at the data, some of the columns are poorly-formed JSON data. They have (for example), single quotation marks where JSON requires double. Changing all the singles to doubles would mess up all of the single quotation marks already present in the data (possessives, french connectives, etc.) and so brute force gsub() and manually editing the data in a spreadsheet were going to end up being too time intensive.

Luckly, Georgi Petkov posted some code on the Kaggle website (https://www.kaggle.com/georgipetkov/json-columns-to-data-frame) that parses this particular data set rather well. It strips all of the punctuations, loads the data into matrices, and then converts them to tibbles.


```{r Petkov cast, warning=FALSE}

cast_list <- list()

for (i in seq_along(data$cast)) {
  cast_list[[i]] <- data$cast[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>%  #extract everything between {}
    str_split("(?<=[:digit:]|[:punct:]), ", n=Inf,simplify = TRUE) %>%       #split on ","
    str_extract_all('(?<=\\:[:space:]).*') %>% #get the part after the semicolon
    str_replace_all("'|\"","") %>% #clean the unwanted punctuation
    matrix( ncol = 8,  byrow = TRUE,dimnames=list(c(),
                                                  c("cast_id","character","credit_id","gender","id", "name","order","profile_path"))) %>% #convert to matrix
    as_tibble(stringsAsFactors = FALSE)#convert the matrix to tibble
}

# Name the list
names(cast_list) <- c(1:3000) #name the list with the sequential number of the list element

# Create df with a column that identifies each movie
cast_df <- bind_rows(cast_list, .id = 'movie_id')#create single df with a column that identifies the movies


cast_df  %>% 
  head(10) %>%
  DT::datatable()

```

```{r Petkov genres, warning=FALSE}
genres_list <- list()
for (i in seq_along(data$genres)) {
  genres_list[[i]] <- data$genres[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("id","name"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(genres_list) <- c(1:3000)

genres_df <- bind_rows(genres_list, .id = 'movie_id')

genres_df %>% 
  head(10) %>% 
  DT::datatable()

# dim(genres_df)

```

```{r Petkov production companies, warning=FALSE}
production_companies_list <- list()
for (i in seq_along(data$production_companies)) {
  production_companies_list[[i]] <- data$production_companies[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    # matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("name","id"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(production_companies_list) <- c(1:3000)

production_companies_df <- bind_rows(production_companies_list, .id = 'movie_id')


production_companies_df %>% 
  head(20) %>% 
  DT::datatable()

```

```{r Petkov crew, warning=FALSE}

crew_list <- list()

for (i in seq_along(data$crew)) {
  crew_list[[i]] <- data$crew[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 7,  byrow = TRUE,dimnames=list(c(),
   c("credit_id","department","gender","id","job","name","profile_path"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(crew_list) <- c(1:3000)

crew_df <- bind_rows(crew_list, .id = 'movie_id')

crew_df%>% 
  head(10) %>% 
  DT::datatable()
```


## 2. Exploratory Data Analysis

Let's see what we have in the 'budget' column.

```{r budget EDA}
plot <- ggplot(data = data) + 
  geom_histogram(aes(x = budget), fill = "dark green", alpha = 0.5)
print(plot)

```

So, most of the movies in the data are very inexpensively made, and by the time we get to $100,000 (1 * 10^8) in the graph, we're dealing with very few.  We also have a ton of movies with a budget of zero, which we can safely assume means the budget is unknown.

Let's zoom on the left side of this graph.

```{r budget2 EDA}
cheap.movies <- subset(data, budget > 0 & budget < 10000000)

plot <- ggplot(data = cheap.movies) + 
  geom_histogram(aes(x = budget), fill = "dark green", alpha = 0.5)
print(plot)

```

Looks like the movies between 0 and 10 million are fairly even distributed, getting more sparse as they approach 10 million.

We can guess that there's some sort of relationship between budget and revenue, but lets visualize and see.

```{r budget and revenue}
nonzero.movies <- subset(data, budget > 0)

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue), color = "dark green", alpha = 0.5)
print(plot)
```

Our guess would appear to be roughly accurate.

Let's add a linear regression line.

```{r budget and revenue with linear regression}
nonzero.movies <- subset(data, budget > 0)

linear.model <- lm(budget ~ revenue, data = nonzero.movies)
predicted.revenue <- data.frame(predicted = predict(linear.model, nonzero.movies))

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue), color = "dark green", alpha = 0.5) +
  geom_line(color = "blue", data = predicted.revenue, aes(x = predicted, y = nonzero.movies$revenue))
print(plot)
```

What about language and budget?

```{r language and budget}
plot <- ggplot(data = data, aes(x = original_language, y = budget)) +
  geom_boxplot(color = "light blue")

print(plot)

```

The only languages that make a dent in budget are English (overwhelmingly the highest budgets), then French, Chinese (both zh and cn (mainland Chinese simplified characters)) and Portuguese. Interestingly, it appears there are no mega-budget Hindi language films.

Let's go back and redo our earlier budget and revenue graph, this time coloring the dots by film language.

```{r budget revenue and language}
nonzero.movies <- subset(data, budget > 0)
nonzero.movies <- mutate(nonzero.movies, is.english = if_else(original_language == "en", "True", "False"))
print(head(nonzero.movies$is.english))

plot <- ggplot(data = nonzero.movies) + 
  geom_point(aes(x = budget, y = revenue, color = is.english), alpha = 0.5)
print(plot)
```

What are those non-English outliers?

```{r non english outliers}
non.english <- subset(nonzero.movies, original_language != "en")
non.english.sorted <- top_n(non.english, 5, revenue)
print(non.english.sorted$original_title)

```

Of those, I've (Mike speaking here) only see "La Vita" and found it amazing. Might be a good viewing list for the future.

```{r Popular movie runtimes}
ggplot(data = data)+
  geom_histogram(mapping = aes(x = runtime), fill = "dark green", alpha = 0.5)+
        geom_vline(xintercept = mean(data$runtime), color = "red", linetype = "dashed")

## Unable to get the mean line working..


```
Most of the movies seem to run for about 100 minutes (1hr 40min) long.

```{r Movie ratings}
ggplot(data = data) +
  geom_boxplot(aes(y = popularity), color = "light blue")+
  coord_cartesian(ylim=c(0,20))

# summary(data$popularity)
```
From the box plot, movies in our dataset has a median rating of 7.5 

```{r Do the movies that have longer runtimes have a bigger budget?}
ggplot(data = data)+
  geom_point(aes(x = runtime, y = budget), color = "dark green", alpha = 0.5)


```
There is no noticable relationsip between movie runtimes and their budget.

```{r Popular genres}
ggplot(data = genres_df)+
  geom_bar(aes(x = name), fill = "dark green", alpha = 0.5)+
  coord_flip()
  # coord_polar()

## Unable to reorder bars form high to low..

```
Most popluar movie genres are dramas, followed by comedy, thriller and action. The drama genre has more more than tiwce the number of movies in the action genre. More than half the movies in our dataset are dramas.


```{r Movie ratings corresponding to its genre / which genre has the highest ratings?}
## I'm trying to write a function here that can subset different genres and calculate the average rating for each genre and show it next to the bar in the graph above.

# (genre_popularity <-data.frame(genres_df$name, data$popularity))


subset(genres_df, name == "Comedy")
as.factor(genres_df$name)




plot <- ggplot(genres_df)+
  geom_bar(aes(x = ))

names(data)

```


```{r Popular production companies}
ggplot(data = production_companies_df)+
  geom_bar(aes(x = name), fill = "dark green", alpha = 0.5)+
  coord_flip()

##Unable to get a clear plot. Am I missing something? Too many and too large company names maybe? How do we visualize this column?
```

```{r How runtimes vary with languages?}
ggplot(data = data, aes(x = fct_reorder(original_language, runtime, .desc = T), y = runtime)) +
  geom_boxplot(color = "dark blue")+
  labs(x = "Original language")
  # coord_flip()


```
Russian movies have the lowest runtimes while Marathi(One of indian language) has the highest runtime. Followed by Tamil (Also an indian languge). Fourth longest is Telugu and fifth is Hindi (Again, both are Indian languages). Indonesia has the third longest runtime and vietnamise comes in at sixth. Overall, south east asian countries seem to have the longest movies.

English movies, which has the largest budget of all the movies don't run longer than movies with less budget. This supports our findings from the budget vs runtime scatter plot where we said there was no clear relationship betweeen movie runtime and it's budget.

Open this link for the language codes: http://www.lingoes.net/en/translator/langcode.htm

```{r Which language has the highest revenue?}
ggplot(data)+
  stat_summary(aes(x = revenue, y = original_language), fun.ymin = min, fun.ymax = max,fun.y = median)+
  coord_flip()

```
English movies seem to have the higest revenue. As we saw earlier, they also have the highest budget from the budget vs origianl laguage boxplot. Chinese, French, Japanese and Hindi movies have similar revenues but nowhere near the english movies.

```{r Make cast vs Female cast}
ggplot(cast_df)+
  geom_bar(aes(x = gender), fill = "dark green", alpha = 0.5)


## Unable to print plot properly. Don't know what's going wrong..!

```

## 3. Feature Engineering

### A. Making a profit column

## 4. Prediction 1

## 5. Validation 1

## 6. Prediction 2

## 7. Validation 2

<!-- and so on... -->

