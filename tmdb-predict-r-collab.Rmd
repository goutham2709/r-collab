---
title: "TMDB Prediction - R-Collab"
author: "Mike and Goutham"
date: "September 22, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TMDB Predict - R Collab

## 1. Data loading and cleaning

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(jsonlite)

```

```{r data loading}
data <- read_csv("train.csv")
print(data)
```

We load our initial data as a tibble, and start inspecting it. As a tibble, we can safely load it and it just gives us the first ten rows with color-coded information on column types.

Let's start with looking at the "genres" column, and seeing if this is correctly formed json we can play with.

```{r genres}

genres <- data$genres
genres <- gsub("\'","\"", genres)
genres <- replace_na(genres, "\"NA\"")
genres <- na.omit(genres)

parsed.genres <- lapply(genres, fromJSON)
print(head(parsed.genres))


```

```{r 2nd parsing function idea}

parse.column <- function(data.input) {
  unparsed <- gsub("\'","\"", data.input) #change single quotes to doubles
  unparsed <- replace_na(unparsed, "\"NA\"") #replace NA with "NA"
  
  # here we fix parsing problems before the parsing begins
  
  gsub("None", "\"None\"", unparsed) # changes None to "None"
  
  # the input gets parsed from JSON into lists
  parsed <- lapply(unparsed, fromJSON) #use JSONlite to parse the input
  
  # here we add data cleaning for specific columns
  if (grepl("Cowgirls n\" Angels", parsed)) {
    gsub("n\"", "n\'", parsed) # fixes the "Cowboys N' Angels" line in id=137 of belongs_to_collection
  }

  
  return(parsed)
}



parsed.data <- tibble("genres" = sapply(data$genres, parse.column),
                      "production_countries" = sapply(data$production_countries, parse.column),
                      "spoken_languages" = sapply(data$spoken_languages, parse.column),
                      "belongs_to_collection" = sapply(data$belongs_to_collection, parse.column))

parsed.data
```

```{r regex cast}

cast_list <- list()

for (i in seq_along(data$cast)) {
  cast_list[[i]] <- data$cast[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>%  #extract everything between {}
    str_split("(?<=[:digit:]|[:punct:]), ", n=Inf,simplify = TRUE) %>%       #split on ","
    str_extract_all('(?<=\\:[:space:]).*') %>% #get the part after the semicolon
    str_replace_all("'|\"","") %>% #clean the unwanted punctuation
    matrix( ncol = 8,  byrow = TRUE,dimnames=list(c(),
                                                  c("cast_id","character","credit_id","gender","id", "name","order","profile_path"))) %>% #convert to matrix
    as_tibble(stringsAsFactors = FALSE)#convert the matrix to tibble
}

# Name the list
names(cast_list) <- c(1:3000) #name the list with the sequential number of the list element

# Create df with a column that identifies each movie
cast_df <- bind_rows(cast_list, .id = 'movie_id')#create single df with a column that identifies the movies


cast_df  %>% 
  head(10) %>%
  DT::datatable()

```

```{r regex genres}
genres_list <- list()
for (i in seq_along(train$genres)) {
  genres_list[[i]] <- train$genres[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("id","name"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(genres_list) <- c(1:3000)

genres_df <- bind_rows(genres_list, .id = 'movie_id')

genres_df %>% 
  head(10) %>% 
  DT::datatable()

```

```{r production companies}
production_companies_list <- list()
for (i in seq_along(train$production_companies)) {
  production_companies_list[[i]] <- train$production_companies[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 2,  byrow = TRUE,dimnames=list(c(),
                                                  c("name","id"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(production_companies_list) <- c(1:3000)

production_companies_df <- bind_rows(production_companies_list, .id = 'movie_id')


production_companies_df %>% 
  head(10) %>% 
  DT::datatable()

```

```{r crew}

crew_list <- list()

for (i in seq_along(train$crew)) {
  crew_list[[i]] <- train$crew[[i]] %>%
    str_extract_all('(?<=\\{).*?(?=\\})') %>% 
    str_split("(?<=[:digit:]|[:punct:]), ",n=Inf,simplify = TRUE) %>% 
    str_extract_all('(?<=\\:[:space:]).*') %>% 
    str_replace_all("[:punct:]","") %>% 
    matrix( ncol = 7,  byrow = TRUE,dimnames=list(c(),
   c("credit_id","department","gender","id","job","name","profile_path"))) %>% 
    as_tibble(stringsAsFactors = FALSE)
}

names(crew_list) <- c(1:3000)

crew_df <- bind_rows(crew_list, .id = 'movie_id')

crew_df%>% 
  head(10) %>% 
  DT::datatable()
```


```{r converting belongs_to_collection into binary}

to.binary <- is.na(data$belongs_to_collection) %>% as.numeric()
# to.binary

```

```{r production_companies}

# production_companies <- data$production_companies
# production_companies <- gsub("\'","\"", production_companies)
# production_companies <- gsub("\'","\"", production_companies)
# production_companies <- replace_na(production_companies, "\"NA\"")
# production_companies <- na.omit(production_companies)
# 
# parsed.production_companies <- lapply(production_companies, fromJSON)
# print(head(parsed.production_companies))

data %>% select(genres) %>% head(3) %>% gsub("\'","\"") %>% replace_na("\"NA\"") %>% na.omit(data)


column_data <- data  %>% 
    select(production_companies) %>%
    map_dfc(.f = parse.column)

# print(column_data)

```

```{r production_countries}

production_countries <- data$production_countries
production_countries <- gsub("\'","\"", production_countries)
production_countries <- replace_na(production_countries, "\"NA\"")
production_countries <- na.omit(production_countries)

parsed.production_companies <- lapply(production_countries, fromJSON)
print(head(parsed.production_companies))

```

```{r spoken_languages}

spoken_languages <- data$spoken_languages
spoken_languages <- gsub("\'","\"", spoken_languages)
spoken_languages <- replace_na(spoken_languages, "\"NA\"")
spoken_languages <- na.omit(spoken_languages)

parsed.spoken_languages <- lapply(spoken_languages, fromJSON)
print(head(parsed.spoken_languages))

```

```{r Keywords}

Keywords <- data$Keywords
Keywords <- gsub("\'","\"", Keywords)
Keywords <- replace_na(Keywords, "\"NA\"")
Keywords <- na.omit(Keywords)

parsed.Keywords <- lapply(Keywords, fromJSON)
print(head(parsed.Keywords))

# Another way
parse.column <- function(x)  {
     str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
     fromJSON(flatten = T) %>% 
     as.tibble()
                                }

column_data <- data$Keywords  %>% 
    map_dfc(.f = parse.column)


```

```{r cast}

cast <- data$cast
cast <- gsub("\'","\"", cast)
cast <- replace_na(cast, "\"NA\"")
cast <- na.omit(cast)

parsed.cast <- lapply(cast, fromJSON)
print(head(parsed.cast))

```

```{r crew}

crew <- data$crew
crew <- gsub("\'","\"", crew)
crew <- replace_na(crew, "\"NA\"")
crew <- na.omit(crew)

parsed.crew <- lapply(crew, fromJSON)
print(head(parsed.crew))

```
The JSON parses doesn't deal with NAs very well, and so this data loses the 7 rows where the genres are NA.  This can possible be dealt with later, but we're on track.


## 2. Exploratory Data Analysis

## 3. Feature Engineering

## 4. Prediction 1

## 5. Validation 1

## 6. Prediction 2

## 7. Validation 2

<!-- and so on... -->

